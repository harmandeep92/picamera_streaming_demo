#!/usr/bin/env python3

from picamera2 import Picamera2
from picamera2.encoders import MJPEGEncoder
from picamera2.outputs import Output
from libcamera import Transform
import io
import logging
import socketserver
from threading import Condition
from http import server

# HTML page for the stream
PAGE = """\
<html>
<head>
<title>Raspberry Pi Camera MJPEG Streaming</title>
</head>
<body>
<h1>Raspberry Pi Camera MJPEG Streaming</h1>
<img src="stream.mjpg" width="1280" height="720" />
</body>
</html>
"""

class StreamingOutput(Output):
    def __init__(self):
        super().__init__()
        self.frame = None
        self.buffer = io.BytesIO()
        self.condition = Condition()

    def outputframe(self, frame, keyframe=True, timestamp=None, packet=None, audio=None):
        self.buffer.seek(0)
        self.buffer.write(frame)
        self.buffer.truncate()
        with self.condition:
            self.frame = self.buffer.getvalue()
            self.condition.notify_all()
        self.buffer.seek(0)

class StreamingHandler(server.BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/':
            self.send_response(301)
            self.send_header('Location', '/index.html')
            self.end_headers()
        elif self.path == '/index.html':
            content = PAGE.encode('utf-8')
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.send_header('Content-Length', len(content))
            self.end_headers()
            self.wfile.write(content)
        elif self.path == '/stream.mjpg':
            self.send_response(200)
            self.send_header('Age', 0)
            self.send_header('Cache-Control', 'no-cache, private')
            self.send_header('Pragma', 'no-cache')
            self.send_header('Content-Type', 'multipart/x-mixed-replace; boundary=FRAME')
            self.end_headers()
            try:
                while True:
                    with output.condition:
                        output.condition.wait()
                        frame = output.frame
                    self.wfile.write(b'--FRAME\r\n')
                    self.send_header('Content-Type', 'image/jpeg')
                    self.send_header('Content-Length', len(frame))
                    self.end_headers()
                    self.wfile.write(frame)
                    self.wfile.write(b'\r\n')
            except Exception as e:
                logging.warning(
                    'Removed streaming client %s: %s',
                    self.client_address, str(e))
        else:
            self.send_error(404)
            self.end_headers()

class StreamingServer(socketserver.ThreadingMixIn, server.HTTPServer):
    allow_reuse_address = True
    daemon_threads = True

if __name__ == "__main__":
    # Initialize Picamera2 with optional tuning file for autofocus
    try:
        picam2 = Picamera2(tuning="/usr/share/libcamera/ipa/rpi/vc4/imx477_af.json")
    except Exception as e:
        print(f"Failed to load tuning file: {e}. Proceeding without it.")
        picam2 = Picamera2()

    # Configure video streaming
    config = picam2.create_video_configuration(main={"size": (1280, 720)}, transform=Transform(hflip=False, vflip=False))
    picam2.configure(config)

    # Set continuous autofocus (if supported)
    try:
        picam2.set_controls({"AfMode": 2})
    except Exception as e:
        print(f"Autofocus not supported or failed: {e}")

    # Start the camera
    output = StreamingOutput()
    encoder = MJPEGEncoder()
    picam2.start_recording(encoder, output)

    # Start the HTTP server
    try:
        address = ('', 8000)
        server = StreamingServer(address, StreamingHandler)
        print("Streaming server started at http://<your-rpi-ip>:8000")
        server.serve_forever()
    except KeyboardInterrupt:
        print("Server stopped by user")
    finally:
        picam2.stop_recording()
        picam2.close()